---
layout: post
title: Much ado about Monads
published: true
---

This is a minimal tutorial on Monads

```haskell
import           Prelude                 hiding ( Monad(..) )
import           Data.Either
import qualified Prelude

class  Monad m where
  -- | Sequentially compose two actions, passing any value produced
  -- by the first as an argument to the second.
  (>>=)       :: m a -> (a -> m b) -> m b
  return      :: a -> m a

instance Monad Maybe where
    (Just x) >>= k = k x
    Nothing  >>= k = Nothing

    return = Just

desugared2 :: Maybe Int -> Maybe Int
desugared2 monkeyWrench =
  Just 3 >>= \a -> 
  monkeyWrench >>= \b -> 
  return $ a + b


instance Monad [] where
  m >>= f   =  concat (map f m)
  return x  =  [x]

m :: [Int]
m = [1, 2, 3, 4]

f :: Int -> [Int]
f = \x -> [1, 0]

demo = m >>= f

instance Monad (Either e) where
  return = Right
  Right m >>= k = k m
  Left e  >>= _ = Left e


demo1 = Left "boom" >>= \x -> return (x + 1)
demo2 = Right 100 >>= \x -> Left "no way!"

instance Monad ((->) r) where
  return a = (\_ -> a)
  m >>= k = \r -> (k (m r)) r

-- just returns the environment
ask :: a -> a
ask = id

-- transforms the env (usually used to access member in record)
asks :: (r -> a) -> (r -> a)
asks f = f

-- Executes a computation in a modified environment. 
local
  :: (r -> r) -- function to modify env
  -> (r -> a)  -- reader to run in the modified env
  -> (r -> a)
local f m = m . f


-- example

data MyContext = MyContext
  { foo :: String
  , bar :: Int
  } deriving (Show)

updateContext :: MyContext -> MyContext
updateContext m = m { foo = "foo" }

computation :: MyContext -> (Maybe String)
computation = asks bar >>= \n -> 
              local updateContext (asks foo) >>= \x -> 
              if n > 0 then 
                return (Just x) 
              else 
                return Nothing

ex1 :: Maybe String
ex1 = computation $ MyContext "hello" 1

ex2 :: Maybe String
ex2 = computation $ MyContext "haskell" 0






instance Monoid w => Monad ((,) w) where
    return a = (mempty, a)
    m >>= k =
        let (w, a)  = m
            (w', b) = k a
        in (w `mappend` w', b)

tell :: w -> (w, ())
tell w = (w, ())

type MyWriter = ([Int], String)

example :: MyWriter
example = do
  tell [1 .. 3]
  tell [3 .. 5]
  return "foo"

output :: ([Int], String)
output = example

newtype State s a = State (s -> (a,s))

instance Monad (State s) where
  return a = State $ \s -> (a, s)

  sm >>= k = State $ \s ->
    let (State st) = sm
        (a, s') = st s
        (State st') = k a
    in st' s'

get :: State s s
get = State $ \s -> (s, s)

put :: s -> State s ()
put s = State $ \_ -> ((), s)

modify :: (s -> s) -> State s ()
modify f = get >>= \x -> put (f x)

instance Monad IO where
  m >>= k = m Prelude.>>= k
  return = Prelude.return

main :: IO ()
main =
  putStrLn "What is your name:" >>= \_ -> 
  getLine >>= \name -> 
  putStrLn name

```
