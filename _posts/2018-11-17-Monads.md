---
layout: post
title: Much ado about Monads
published: true
---

This is a minimal tutorial on Monads i.e. the mechanics rather than the philosophy. I'm not going to convince you that 
they're important or beautiful or magical or powerful.

Also the explanation will be in the spirit of rigor/correctness rather than formally/technically so. So while the code does type check
and compile (at least as of GHC 8.4.3) and I think I haven't violated any of the Monad laws these are not the actual definitions/implementations. 
Consequently I'm not going to cover Monad transformers.

**Strong recommendation**

Reduce all expressions to their most basic forms by hand (maybe on paper) in order to really understand what's going on.
That means transform each use of `>>=` and `return` into their definition in the Monad.

**Note you need to include**

```haskell
import Prelude hiding (Monad(..))
```

at the top of your script in order to shadow default implementations if you plan to follow along.


## Dictionary

The only syntax/concepts you need to understand 

 syntax | definition | parallel |
------- | -------- | --------- |
 `foo :: Int` | `Int` type value `foo` | Types in any statically type language |
 `foo :: Bar Int` | Algebraic data type `Bar` composed with type `Int` | no clue (this is algebraic data types) | 
 `foo :: Int -> String` | Type signature of function `foo` from type `Int` to type `String` | Types in any statically type language |
 `foo :: Int -> Int -> String` | Type signature of two argument function `foo` from type `Int, Int` to type `String` | Types in any statically type language |
 `foo :: a -> b` | Type signature of generic `foo` from any type `a` to any type `b` | Types in any statically type language with generics |
 `class Foo m where` | Parametric type class `Foo` with type parameter `m` | `public interface Foo` in Java |
 `class Baz m => Foo m where` | Parametric type class `Foo` with type parameter `m` with bounded type m | `public class Moo implements Foo, Baz` in Java  |
 `(+)` | "prefixification" of an infix operator `+` | no clue |
 `instance Foo Bar where` | Instantiation of type class `Foo` by type `Bar` | `public class Bar implements Foo` |
 `instance Foo (Bar e) where` | Instantiation of type class `Foo` by parametric type `Bar` | `public class Bar<E> implements Foo` |
 `instance Baz e => Foo (Bar e) where` | Instantiation of type class `Foo` by parametric type `Bar` with bounded type e | `public class Bar<e extends Bar> implements Foo` |
 `\x -> 2*x` | Lambda function with parameter `x` | `lambda x: 2*x` in python |
 `f x` | `f` applied to `x` | `f(x)`  |
 `f $ g x` | `f` applied to `g` applied to `x` (saves parentheses in `f (g x)`)  | `f(g(x))`  |
 `f . g $ x` | `f` composed with `g` | `f(g(x))`  |
 `data Env = Env { foo :: String, bar :: Int} deriving (Show)` | Record | Structs in C++ with default `cout <<` representation (note that `Env` on the left side of `=` is different from `Env` on the right - left is type, right is the constructor [and they could be named distinctly] ) |

You also need to understand [**algebraic data types**](https://en.wikipedia.org/wiki/Algebraic_data_type) but I'm not going to explain that.

## A utilitarian definition of Monads



A `Monad` is a type class whose instances implement two functions/operators: `>>=` and `return` (note `return` is a function not a keyword)
 which themselves abide by the [Monad laws](https://wiki.haskell.org/Monad_laws) (though you should skip reading these until you finish this post).

```haskell
class Monad mon where
  (>>=)       :: m a -> (a -> m b) -> m b 
  return      :: a -> m a
```

`>>=` takes a value of type `m a` (i.e. a value of the type that implements the interface) on the left and a function with signature `k :: a -> m b` 
on the right and then in toto returns a new value of the type `m b`. The function `k :: a -> m b` that takes a value of type `a` and returns a value of type `m a`.
You can think of this function `k` as a callback.

`return` takes a value of type `a` and returns a type of `m a`.

Keep in mind that each Monad instance stands or falls on its own merits and that the only thing in common between all of them is that they implement these 
functions.


## Maybe

The simplest Monad to reason about is `Maybe`:

```haskell

instance Monad Maybe where
    m >>= k = case m of
        (Just x) -> k x
        Nothing -> Nothing

    return = Just
```

What does this do? If `m` is the `Just` variant of `Maybe` then `>>=` just passes the wrapped value `x` on to the callback `k`.
Otherwise (if `m` is the `Nothing` variant) `>>=` don't pass anything and doesn't even call the callback. 

In a phrase: `Monad Maybe` is for sequences of functions each of which can fail.

An illustration:

```haskell
trivial :: Maybe Int -> Maybe Int
trivial monkeyWrench =
    Just 3 >>= \a -> 
    monkeyWrench >>= \b -> 
    return $ a + b

obvSuccess = trivial $ Maybe 5
-- obvSuccess == Just 8

obvFail = trivial $ Nothing
-- obvFail == Nothing
```

The heuristic way to think about the composition `Just 3 >>= \a ->` is that the "inner" value in the `Just` is bound to the `a`.

I'll point out that this would be useful for example in python where if you scrape using BeautifulSoup you end writing things like

```python 
from bs4 import BeautifulSoup
soup = BeautifulSoup(html_doc, 'html.parser')
 
maybe_div = soup.find('div')

if maybe_div is not None:
    maybe_tr = maybe_div.find('tr')
    if maybe_tr is not None:
        maybe_td = maybe_tr.find('td')
        if ...
```

## List

The `List` Monad instance "models" multiple results.

```haskell
instance Monad [] where
    m >>= f = concat (map f m)
    return x = [x]
```


```haskell
m :: [Int]
m = [1, 2, 3, 4]

f :: Int -> [Int]
f = \x -> [x, 2*x]

sameAndDouble = m >>= f
-- [1,2,2,4,3,6]
```

Not the most useful thing in the world with one application but with two you can, for example, compute cartesian product.

```haskell
cartProduct = [1,2,3] >>= \x -> 
              [4,5,6] >>= \y -> 
              return (x,y)
-- [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
```

## Either

`Either` is basically exactly the same as `Maybe`.

```haskell
instance Monad (Either e) where

    m >>= k = case m of
        (Right x) -> k x
        (Left e) -> Left e
    
    return = Right
```

Only difference is that `Either` is simply more useful (in that it passes on a message on short-circuit).


```haskell
trivialEither :: Either String Int -> Either String Int
trivialEither monkeyWrench =
    Right 3 >>= \a -> 
    monkeyWrench >>= \b -> 
    return $ a + b

obvSuccess = trivialEither $ Right 5
-- obvSuccess == Right 8

obvFail = trivialEither $ Left "nbd"
-- obvFail == Left "nbd"
```

## Code

```haskell
import           Prelude                 hiding ( Monad(..) )
import           Data.Either
import qualified Prelude

class  Monad m where
  -- | Sequentially compose two actions, passing any value produced
  -- by the first as an argument to the second.
  (>>=)       :: m a -> (a -> m b) -> m b
  return      :: a -> m a

instance Monad Maybe where
    (Just x) >>= k = k x
    Nothing  >>= k = Nothing

    return = Just

desugared2 :: Maybe Int -> Maybe Int
desugared2 monkeyWrench =
  Just 3 >>= \a -> 
  monkeyWrench >>= \b -> 
  return $ a + b


instance Monad [] where
  m >>= f   =  concat (map f m)
  return x  =  [x]

m :: [Int]
m = [1, 2, 3, 4]

f :: Int -> [Int]
f = \x -> [1, 0]

demo = m >>= f

instance Monad (Either e) where
  return = Right
  Right m >>= k = k m
  Left e  >>= _ = Left e


demo1 = Left "boom" >>= \x -> return (x + 1)
demo2 = Right 100 >>= \x -> Left "no way!"

instance Monad ((->) r) where
  return a = (\_ -> a)
  m >>= k = \r -> (k (m r)) r

-- just returns the environment
ask :: a -> a
ask = id

-- transforms the env (usually used to access member in record)
asks :: (r -> a) -> (r -> a)
asks f = f

-- Executes a computation in a modified environment. 
local
  :: (r -> r) -- function to modify env
  -> (r -> a)  -- reader to run in the modified env
  -> (r -> a)
local f m = m . f


-- example

data MyContext = MyContext
  { foo :: String
  , bar :: Int
  } deriving (Show)

updateContext :: MyContext -> MyContext
updateContext m = m { foo = "foo" }

computation :: MyContext -> (Maybe String)
computation = asks bar >>= \n -> 
              local updateContext (asks foo) >>= \x -> 
              if n > 0 then 
                return (Just x) 
              else 
                return Nothing

ex1 :: Maybe String
ex1 = computation $ MyContext "hello" 1

ex2 :: Maybe String
ex2 = computation $ MyContext "haskell" 0






instance Monoid w => Monad ((,) w) where
    return a = (mempty, a)
    m >>= k =
        let (w, a)  = m
            (w', b) = k a
        in (w `mappend` w', b)

tell :: w -> (w, ())
tell w = (w, ())

type MyWriter = ([Int], String)

example :: MyWriter
example = do
  tell [1 .. 3]
  tell [3 .. 5]
  return "foo"

output :: ([Int], String)
output = example

newtype State s a = State (s -> (a,s))

instance Monad (State s) where
  return a = State $ \s -> (a, s)

  sm >>= k = State $ \s ->
    let (State st) = sm
        (a, s') = st s
        (State st') = k a
    in st' s'

get :: State s s
get = State $ \s -> (s, s)

put :: s -> State s ()
put s = State $ \_ -> ((), s)

modify :: (s -> s) -> State s ()
modify f = get >>= \x -> put (f x)

instance Monad IO where
  m >>= k = m Prelude.>>= k
  return = Prelude.return

main :: IO ()
main =
  putStrLn "What is your name:" >>= \_ -> 
  getLine >>= \name -> 
  putStrLn name

```
