---
layout: post
title: Minimax
published: true
---

A game can be thought of as a tree of possible future game states.
The current state of the game is the root of the tree (drawn at the top).
In general this node has several children, representing all of the possible moves that we could make. Each of those nodes has children representing the game state after each of the opponent's moves. These nodes have children corresponding to the possible second moves of the current player, and so on. The leaves of the tree are final states of the game: states where no further move can be made because one player has won, or perhaps the game is a tie.

# Search

Suppose that we assign a value of positive infinity to a leaf state in which we win, negative infinity to states in which the opponent wins, and zero to tie states.

Usually expanding the entire game tree is infeasible because there are so many possible states. The solution is to only search the tree to a specified depth. Define and `evaluate` function (the static evaluator) returns a value between $-\infty$ and $\infty$ for game positions that are not final positions. For game positions that look better for the player, it returns larger numbers, for game positions that look better for the opponent (look bad for the player) it returns small numbers (negatives too). When the depth limit of the search is exceeded, the static evaluator is applied to the node as if it were a leaf:

If we can traverse the entire game tree, we can figure out whether the game is a win for the current player **assuming perfect play**: we assign a value to the current game state by we recursively walking the tree. At leaf nodes we return the appropriate values (either declare win $\infty$/loss $-\infty$ or the result of `evaluate`). At nodes where we get to move, we take the max of the child values because we want to pick the best move; **at nodes where the opponent moves we take the min of child values** because we assume perfect play on the part of the opponent and they'll pick the smallest number. This gives us the following schematic evalution of a game tree
<p>
<img style="display:block; margin:auto;" src="{{ "/images/minimax.svg" | absolute_url }}">
</p>
and the following pseudo-code procedure for minimax evaluation of a game tree (remember the player is trying to drive the score positive and the opponent is trying to drive the score negative):

```
def minimax(n: node, depth: int, max_depth: int) -> int:
    if leaf(n) or depth == max_depth: return evaluate(n)
    
    if is_max_node(n): 
        value = $-\infty$ # initialization for max
        for each child of n:
            value = max(value, minimax(child, depth+1, max_depth))
    elif is_min_node(n):
        value = $\infty$ # initialization for min
        for each child of n:
            value = min(value, minimax(child, depth+1, max_depth))
            
    return value
        
```

# Alpha-beta pruning

The full minimax search explores some parts of the tree it doesn't have to: for example in this game tree

<p>
<img style="display:block; margin:auto;" src="{{ "/images/ab_pruning.jpg" | absolute_url }}">
</p>

in the **right most** subtree as soon as the  player discovers that there's a move that forces the opponent to choose `8` (as their move for the next round) they can stop considering children because it's already known the opponent will force the player to choose `5` (the just adjacent tree).
